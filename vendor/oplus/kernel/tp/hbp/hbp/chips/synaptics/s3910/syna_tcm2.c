#include "syna_tcm2.h"

#define PLATFORM_DRIVER_NAME "syna_tcm2"
#define INPUT_RESOLUTION_NUM  16
/*
static int syna_dev_write(void *priv, void *data, int32_t len)
{
	struct syna_tcm *tcm_hcd = (struct syna_tcm *)priv;

	return tcm_hcd->bus_ops->write_block(tcm_hcd->bus_ops, data, len);

}

static int syna_dev_read(void *priv, char *data, int32_t len)
{
	struct syna_tcm *tcm_hcd = (struct syna_tcm *)priv;
	return tcm_hcd->bus_ops->read_block(tcm_hcd->bus_ops, data, len);
}
*/
static int syna_spi_sync(void *priv, char *tx, char *rx, int32_t len)
{
	struct syna_tcm *tcm_hcd = (struct syna_tcm *)priv;
	int ret = 0;

	LOGD("%s:%*ph\n", "WR", len, tx);

	ret = tcm_hcd->bus_ops->spi_sync(tcm_hcd->bus_ops, tx, rx, len);

	LOGD("%s:%*ph\n", "RD", len, rx);

	return ret;
}

static int syna_get_frame(void *priv, u8 *raw, u32 rawsize)
{
	int retval;
	//u8 *offset = raw;
	struct syna_tcm *tcm_hcd = (struct syna_tcm *)priv;
	const int header_size = 3;
	unsigned int total_size = 0;

	if (!raw) {
		hbp_err("raw is NULL\n");
		return -1;
	}

	if (!tcm_hcd->probe_done) {
		hbp_err("probe not done\n");
		return -1;
	}

	LOGD("%s start\n", __func__);
	// /* retrieve the original report date generated by firmware */
	// tcm_hcd->status_report_code = 0;
	// retval = syna_tcm_get_event_data(tcm_hcd->tcm_dev,
	// 		&tcm_hcd->status_report_code,
	// 		&tcm_hcd->event_data);
	// if (retval < 0) {
	// 	hbp_err("Fail to get event data\n");
	// 	return -1;
	// }
/*
	if (tcm_hcd->status_report_code == REPORT_DELTA
			|| tcm_hcd->status_report_code == REPORT_RAW
			|| tcm_hcd->status_report_code == REPORT_DEBUG) {
		syna_tcm_test_report(tcm, tcm_hcd->status_report_code);
		goto exit;
	}
*/
	//if (tcm_hcd->report_to_queue[tcm_hcd->status_report_code] == EFP_ENABLE) {
	syna_tcm_buf_lock(&tcm_hcd->tcm_dev->external_buf);
	memset(raw, 0x0, rawsize);
	total_size = tcm_hcd->tcm_dev->external_buf.data_length + header_size;
	//hbp_debug("Length of queuing data = %d\n", tcm_hcd->tcm_dev->external_buf.data_length);
	//hbp_debug("Total size = %d, raw size = %d\n", total_size, rawsize);
	raw[0] = tcm_hcd->status_report_code;
	raw[1] = (unsigned char)tcm_hcd->tcm_dev->external_buf.data_length;
	raw[2] = (unsigned char)(tcm_hcd->tcm_dev->external_buf.data_length >> 8);
	if (tcm_hcd->tcm_dev->external_buf.data_length > 0) {
		retval = syna_pal_mem_cpy(&raw[header_size],
				(total_size - header_size),
				tcm_hcd->tcm_dev->external_buf.buf,
				tcm_hcd->tcm_dev->external_buf.data_length,
				tcm_hcd->tcm_dev->external_buf.data_length);
		if (retval < 0) {
			hbp_err("Fail to copy data to buffer, size: %d\n",
				tcm_hcd->tcm_dev->external_buf.data_length);
			return -1;
		}
	}
	syna_tcm_buf_unlock(&tcm_hcd->tcm_dev->external_buf);
	LOGD("%s end\n", __func__);
		//return 0;
	//}
/*
	if (tcm->tp_data_record_support) {
		if (tcm_hcd->status_report_code == REPORT_DIFF) {
			syna_get_diff_data_record(tcm);
		}
	}

	if (tcm_hcd->status_report_code == REPORT_LOG) {
		syna_get_report_log_data(tcm);
	}
*/
	/* report input event only when receiving a touch report */
/*
	if (tcm_hcd->status_report_code == REPORT_TOUCH) {
		retval = syna_tcm_parse_touch_report(tcm->tcm_dev,
				tcm->event_data.buf,
				tcm->event_data.data_length,
				&tcm->tp_data);
		if (retval < 0) {
			hbp_err("Fail to parse touch report\n");
			goto exit;
		}
		syna_dev_report_input_events(tcm);
	}
*/
	return 0;
}

static int syna_get_irq_reason(void *priv, enum irq_reason *reason)
{
	struct syna_tcm *tcm_hcd = (struct syna_tcm *)priv;
	int retval = 0;

	if (!tcm_hcd->probe_done) {
		hbp_err("probe not done\n");
		return -1;
	}

	if (tcm_hcd->char_dev_irq_disabled) {
		hbp_err("char dev irq is disabled\n");
		return -1;
	}

	/* TODO: get event data */
	tcm_hcd->status_report_code = 0;

	retval = syna_tcm_get_event_data(tcm_hcd->tcm_dev,
			&tcm_hcd->status_report_code,
			&tcm_hcd->event_data);
	if (retval < 0) {
		hbp_err("Fail to get event data\n");
		hbp_dev_ctrl_hw_reset();
		return -1;
	}

	if (tcm_hcd->status_report_code == REPORT_IDENTIFY) {
		hbp_info("Received REPORT_IDENTIFY, device has been reset.\n");
		*reason = IRQ_REASON_RESET_IDENTIFY;
	} else if (tcm_hcd->status_report_code == REPORT_TOUCH) {
		hbp_info("Received LBP touch report, please check mode correct or not.\n");
		*reason = IRQ_REASON_LBP_POINTS_REPORT;
	} else if (tcm_hcd->status_report_code < REPORT_IDENTIFY
			|| tcm_hcd->status_report_code == REPORT_DELTA
			|| tcm_hcd->status_report_code == REPORT_RAW
			|| tcm_hcd->status_report_code == REPORT_DEBUG) {
		*reason = IRQ_REASON_RESPONSE;
	} else if (tcm_hcd->status_report_code == REPORT_DIFF) {
		*reason = IRQ_REASON_GESTURE_DIFF;
	}

	return 0;
}

static void finger_err_handle(struct tcm_touch_data_blob *touch_data)
{
	hbp_info("TP_FP_ERROR_REPORT:fingerprint error type:[%*ph]\n", 6, touch_data->extra_gesture_info);
	switch (touch_data->extra_gesture_info[0]) {
	case FINGERPRINT_AREA_NOT_MATCH:
		/* if (tcm->health_monitor_support) {
			tp_healthinfo_report(&tcm->monitor_data, HEALTH_REPORT, "fingerprint_area_not_match_count");
		} */
		hbp_info("TP_FP_ERROR_REPORT:area size: 0x%x\n", touch_data->extra_gesture_info[2]);
		hbp_info("TP_FP_ERROR_REPORT:FINGERPRINT_AREA_NOT_MATCH\n");
		break;
	case ANOTHER_FINGER_ON_NON_FP_ZONE:
		/*if (tcm->health_monitor_support) {
			tp_healthinfo_report(&tcm->monitor_data, HEALTH_REPORT, "another_finger_on_non-fingerprint_zone_count");
		} */
		hbp_info("TP_FP_ERROR_REPORT:x:0x%x,y:0x%x\n",
			(touch_data->extra_gesture_info[3] << 8) + touch_data->extra_gesture_info[2],
			(touch_data->extra_gesture_info[5] << 8) + touch_data->extra_gesture_info[4]);
		hbp_info("TP_FP_ERROR_REPORT:ANOTHER_FINGER_ON_NON_FP_ZONE\n");
		break;
	case FINGERPRINT_DOWN_BEFORE_FP_ENABLE:
		/* if (tcm->health_monitor_support) {
			tp_healthinfo_report(&tcm->monitor_data, HEALTH_REPORT, "fingerprint_down_before_fp_enable_count");
		} */
		hbp_info("TP_FP_ERROR_REPORT:down time: 0x%x\n", touch_data->extra_gesture_info[2]);
		hbp_info("TP_FP_ERROR_REPORT:FINGERPRINT_DOWN_BEFORE_FP_ENABLE\n");
		break;
	case FINGERPRINT_OUT_MOVE_IN:
		/* if (tcm->health_monitor_support) {
			tp_healthinfo_report(&tcm->monitor_data, HEALTH_REPORT, "fingerprint_out_move_in_count");
		} */
		hbp_info("TP_FP_ERROR_REPORT:FINGERPRINT_OUT_MOVE_IN\n");
		break;
	default:
		hbp_info("TP_FP_ERROR_REPORT:unknown fingerprint error type: 0x%x\n", touch_data->extra_gesture_info[0]);
		break;
	}
	return;
}

static int syna_get_gesture(void *priv, struct gesture_info *gesture)
{
	struct syna_tcm *tcm_hcd = (struct syna_tcm *)priv;
	struct tcm_touch_data_blob *touch_data;
	int retval = 0;

	if (!tcm_hcd->probe_done) {
		hbp_err("probe not done\n");
		return -1;
	}

	if (tcm_hcd->char_dev_irq_disabled) {
		hbp_err("char dev irq is disabled\n");
		return -1;
	}

	/* TODO: get gesture */
	// tcm_hcd->status_report_code = 0;
	// retval = syna_tcm_get_event_data(tcm_hcd->tcm_dev,
	// 		&tcm_hcd->status_report_code,
	// 		&tcm_hcd->event_data);
	// if (retval < 0) {
	// 	hbp_err("Fail to get event data\n");
	// 	return -1;
	// }
	retval = syna_tcm_parse_touch_report(tcm_hcd->tcm_dev,
				tcm_hcd->event_data.buf,
				tcm_hcd->event_data.data_length,
				&tcm_hcd->tp_data);

	touch_data = &tcm_hcd->tp_data;
	gesture->type = UnknownGesture;

	memset(&gesture->Point_start, 0, sizeof(struct Coordinate));
	memset(&gesture->Point_end, 0, sizeof(struct Coordinate));
	memset(&gesture->Point_1st, 0, sizeof(struct Coordinate));
	memset(&gesture->Point_2nd, 0, sizeof(struct Coordinate));
	memset(&gesture->Point_3rd, 0, sizeof(struct Coordinate));
	memset(&gesture->Point_4th, 0, sizeof(struct Coordinate));

	switch (touch_data->gesture_id) {
	case DTAP_DETECT:
		gesture->type = DoubleTap;
		break;
	case CIRCLE_DETECT:
		gesture->type = Circle;

		if (touch_data->extra_gesture_info[2] == 0x10) {
			gesture->clockwise = 1;

		} else if (touch_data->extra_gesture_info[2] == 0x20) {
			gesture->clockwise = 0;
		}
		break;
	case SWIPE_DETECT:
		if (touch_data->extra_gesture_info[4] == 0x41) { /*x+*/
			gesture->type = Left2RightSwip;

		} else if (touch_data->extra_gesture_info[4] == 0x42) { /*x-*/
			gesture->type = Right2LeftSwip;

		} else if (touch_data->extra_gesture_info[4] == 0x44) { /*y+*/
			gesture->type = Up2DownSwip;

		} else if (touch_data->extra_gesture_info[4] == 0x48) { /*y-*/
			gesture->type = Down2UpSwip;

		} else if (touch_data->extra_gesture_info[4] == 0x81) { /*2x-*/
			gesture->type = DoubleSwip;

		} else if (touch_data->extra_gesture_info[4] == 0x82) { /*2x+*/
			gesture->type = DoubleSwip;

		} else if (touch_data->extra_gesture_info[4] == 0x84) { /*2y+*/
			gesture->type = DoubleSwip;

		} else if (touch_data->extra_gesture_info[4] == 0x88) { /*2y-*/
			gesture->type = DoubleSwip;
		}
		break;
	case M_UNICODE:
		gesture->type = Mgestrue;
		break;
	case W_UNICODE:
		gesture->type = Wgestrue;
		break;
	case VEE_DETECT:
		if (touch_data->extra_gesture_info[2] == 0x02) { /*up*/
			gesture->type = UpVee;

		} else if (touch_data->extra_gesture_info[2] == 0x01) { /*down*/
			gesture->type = DownVee;

		} else if (touch_data->extra_gesture_info[2] == 0x08) { /*left*/
			gesture->type = LeftVee;

		} else if (touch_data->extra_gesture_info[2] == 0x04) { /*right*/
			gesture->type = RightVee;
		}
		break;
	case TOUCH_HOLD_DOWN:
		gesture->type = FingerprintDown;
		break;
	case TOUCH_HOLD_EARLY_DOWN:
		gesture->type = FingerprintEarlyDown;
		break;
	case TOUCH_HOLD_UP:
		gesture->type = FingerprintUp;
		break;
	case FINGERPRINT_ERR_REPORT:
		finger_err_handle(touch_data);
		break;
	case HEART_DETECT:
		gesture->type = Heart;
		if (touch_data->extra_gesture_info[2] == 0x10) {
			gesture->clockwise = 1;

		} else if (touch_data->extra_gesture_info[2] == 0x20) {
			gesture->clockwise = 0;
		}
		break;
	case STAP_DETECT:
		gesture->type = SingleTap;
		break;
	case S_UNICODE:
		gesture->type = SGesture;
		break;
	case TRIANGLE_DETECT:
	default:
		hbp_err("not support\n");
		break;
	}
	if (gesture->type == FingerprintDown || gesture->type == FingerprintEarlyDown
		|| gesture->type == FingerprintUp) {
		gesture->Point_start.x = touch_data->data_point[0] | (touch_data->data_point[1] << 8);
		gesture->Point_start.y = touch_data->data_point[2] | (touch_data->data_point[3] << 8);
		gesture->tp_firmware_time = touch_data->data_point[5];
		gesture->Point_end.x = TOUCH_HOLD_AREA_RATE_DEFAULT;
		gesture->Point_end.y = 0;
	} else if (gesture->type == SingleTap || gesture->type == DoubleTap) {
		gesture->Point_start.x = (touch_data->extra_gesture_info[0] |
					   (touch_data->extra_gesture_info[1] << 8)) / 10 * INPUT_RESOLUTION_NUM;
		gesture->Point_start.y = (touch_data->extra_gesture_info[2] |
					   (touch_data->extra_gesture_info[3] << 8)) / 10 * INPUT_RESOLUTION_NUM;
	} else if (gesture->type != UnknownGesture) {
		gesture->Point_start.x = (touch_data->data_point[0] |
					   (touch_data->data_point[1] << 8)) / 10 * INPUT_RESOLUTION_NUM;
		gesture->Point_start.y = (touch_data->data_point[2] |
					   (touch_data->data_point[3] << 8)) / 10 * INPUT_RESOLUTION_NUM;
		gesture->Point_end.x    = (touch_data->data_point[4] |
					   (touch_data->data_point[5] << 8)) / 10 * INPUT_RESOLUTION_NUM;
		gesture->Point_end.y    = (touch_data->data_point[6] |
					   (touch_data->data_point[7] << 8)) / 10 * INPUT_RESOLUTION_NUM;
		gesture->Point_1st.x    = (touch_data->data_point[8] |
					   (touch_data->data_point[9] << 8)) / 10 * INPUT_RESOLUTION_NUM;
		gesture->Point_1st.y    = (touch_data->data_point[10] |
					   (touch_data->data_point[11] << 8)) / 10 * INPUT_RESOLUTION_NUM;
		gesture->Point_2nd.x    = (touch_data->data_point[12] |
					   (touch_data->data_point[13] << 8)) / 10 * INPUT_RESOLUTION_NUM;
		gesture->Point_2nd.y    = (touch_data->data_point[14] |
					   (touch_data->data_point[15] << 8)) / 10 * INPUT_RESOLUTION_NUM;
		gesture->Point_3rd.x    = (touch_data->data_point[16] |
					   (touch_data->data_point[17] << 8)) / 10 * INPUT_RESOLUTION_NUM;
		gesture->Point_3rd.y    = (touch_data->data_point[18] |
					   (touch_data->data_point[19] << 8)) / 10 * INPUT_RESOLUTION_NUM;
		gesture->Point_4th.x    = (touch_data->data_point[20] |
					   (touch_data->data_point[21] << 8)) / 10 * INPUT_RESOLUTION_NUM;
		gesture->Point_4th.y    = (touch_data->data_point[22] |
					   (touch_data->data_point[23] << 8)) / 10 * INPUT_RESOLUTION_NUM;
	}
	hbp_info("lpwg:0x%x, type:%d, clockwise: %d, points: (%d, %d)(%d, %d)(%d, %d)(%d, %d)(%d, %d)(%d, %d)\n",
		 touch_data->gesture_id, gesture->type, gesture->clockwise, \
		 gesture->Point_start.x, gesture->Point_start.y, \
		 gesture->Point_end.x, gesture->Point_end.y, \
		 gesture->Point_1st.x, gesture->Point_1st.y, \
		 gesture->Point_2nd.x, gesture->Point_2nd.y, \
		 gesture->Point_3rd.x, gesture->Point_3rd.y, \
		 gesture->Point_4th.x, gesture->Point_4th.y);
	return 0;
}

static int syna_get_touch_points(void *priv, struct point_info *points)
{
	int retval, idx = 0;
	int obj_attention = 0;
	//u8 *offset = raw;
	struct syna_tcm *tcm_hcd = (struct syna_tcm *)priv;
	unsigned int max_objects = 0;
	//struct tcm_touch_data_blob *touch_data;
	struct tcm_objects_data_blob *object_data;

	if (!tcm_hcd->probe_done) {
		hbp_err("probe not done\n");
		return -1;
	}

	if (tcm_hcd->char_dev_irq_disabled) {
		hbp_err("char dev irq is disabled\n");
		return -1;
	}

	/* TODO: get touch points */
	// tcm_hcd->status_report_code = 0;
	// retval = syna_tcm_get_event_data(tcm_hcd->tcm_dev,
	// 		&tcm_hcd->status_report_code,
	// 		&tcm_hcd->event_data);
	// if (retval < 0) {
	// 	hbp_err("Fail to get event data\n");
	// 	return -1;
	// }
	//if (tcm_hcd->status_report_code == REPORT_TOUCH) {
	retval = syna_tcm_parse_touch_report(tcm_hcd->tcm_dev,
				tcm_hcd->event_data.buf,
				tcm_hcd->event_data.data_length,
				&tcm_hcd->tp_data);

	max_objects = tcm_hcd->tcm_dev->max_objects;
	//touch_data = &tcm_hcd->tp_data;
	object_data = &tcm_hcd->tp_data.object_data[0];

	for (idx = 0; idx < max_objects; idx++) {
		switch (object_data[idx].status) {
		case FINGER:
		case GLOVED_OBJECT:
			points[idx].status = 1;
			points[idx].x = object_data[idx].x_pos * INPUT_RESOLUTION_NUM / 10;
			points[idx].y = object_data[idx].y_pos * INPUT_RESOLUTION_NUM / 10;
			points[idx].touch_major = object_data[idx].x_width;
			points[idx].width_major = object_data[idx].y_width;
			obj_attention = obj_attention | (1 << idx);
			hbp_info("Finger %d: x = %d, y = %d\n", idx, points[idx].x, points[idx].y);
			break;
		default:
			break;
		}
	}
	//}
	return obj_attention;
}

int syna_enable_hbp_mode(void *priv, bool en)
{
	struct syna_tcm *tcm = (struct syna_tcm *)priv;
	int retval = 0;

	// /* disable LBP active frame report(REPORT_TOUCH = 0x11) */
	// retval = syna_tcm_enable_report(tcm->tcm_dev,
	// 		 REPORT_TOUCH, false);
	// if (retval < 0) {
	//      hbp_err("Fail to disalbe HBP Active Frame report\n");
	//      goto exit;
	// }
	hbp_info("%s start, en=%u\n", __func__, en);
	/* disable LBP mode: 2-LBP(default),1-HBP */
	if (!en) {
		retval = syna_tcm_set_dynamic_config(tcm->tcm_dev,
				DC_CONTROL_LBP_HBP,
				en ? 0x01 : 0x02,
				RESP_IN_ATTN);
		if (retval < 0) {
			hbp_err("Fail to disable LBP mode via DC command\n");
			goto exit;
		}

		/* enable log report to detect fw enter/exit force doze mode */
		retval = syna_tcm_enable_report(tcm->tcm_dev, REPORT_LOG, true);
		if (retval < 0) {
			hbp_err("Failed to enable log report\n");
			goto exit;
		}
		hbp_info("Enable log report\n");
	}
	//tcm->hbp_enabled = true;

	hbp_info("%s end\n", __func__);
exit:
	return retval;
}

struct dev_operations syna_ops = {
	.spi_sync = syna_spi_sync,
	.get_frame = syna_get_frame,
	.get_gesture = syna_get_gesture,
	.get_touch_points = syna_get_touch_points,
	.get_irq_reason = syna_get_irq_reason,
	.enable_hbp_mode = syna_enable_hbp_mode,
};

static int syna_dev_probe(struct platform_device *pdev)
{
	struct syna_tcm *tcm_hcd;
	struct tcm_dev *tcm_dev = NULL;
	struct chip_info info;
	int ret = 0;
	int retry = 0;

	//TODO:need get from dts
	if (!match_from_cmdline(&pdev->dev, &info)) {
		return 0;
	}

	tcm_hcd = kzalloc(sizeof(*tcm_hcd), GFP_KERNEL);
	if (!tcm_hcd) {
		hbp_err("Failed to allocate memory for tcm_hcd\n");
		return -ENOMEM;
	}

	ret = syna_tcm_allocate_device(&tcm_dev, RESP_IN_POLLING);
	if ((ret < 0) || (!tcm_dev)) {
		hbp_err("Fail to allocate TouchCom device handle\n");
		kfree(tcm_hcd);
		return -ENOMEM;
	}

	platform_set_drvdata(pdev, tcm_hcd);
	tcm_hcd->pdev = pdev;
	tcm_hcd->tcm_dev = tcm_dev;


	ret = hbp_register_devices(tcm_hcd,
								&pdev->dev,
								&syna_ops,
								&info,
								&tcm_hcd->bus_ops);
	if (ret < 0) {
		hbp_info("failed to register device\n");
		goto err_exit;
	}

	tcm_hcd->tcm_dev->bus_ops = tcm_hcd->bus_ops;

	syna_tcm_buf_init(&tcm_hcd->event_data);
	//fhp_chip_debug_init(fts);

	/* create the device file and register to char device classes */
	ret = syna_cdev_create_sysfs(tcm_hcd, pdev);
	if (ret < 0) {
		hbp_err("Fail to create the device sysfs\n");
		goto err_exit;
	}

	for (retry = 0; retry < 5; retry++) {
		ret = syna_tcm_detect_device(tcm_hcd->tcm_dev);
		if (ret >= 0) {
			break;
		}
		hbp_err("Detect device fail, retry = %d.\n", retry);
		hbp_dev_ctrl_hw_reset();
	}

	tcm_hcd->probe_done = true;
	hbp_info("probe end\n");
	return 0;

err_exit:
	return ret;
}

#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 12, 0))
static void syna_dev_remove(struct platform_device *pdev)
#else
static int syna_dev_remove(struct platform_device *pdev)
#endif
{
	hbp_info("syna_dev_remove.\n");
#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 12, 0))
#else
	return 0;
#endif
}

static struct of_device_id syna_tcm2_of_match[] = {
	{ .compatible = "synaptics-tcm" },
	{},
};

static struct platform_driver syna_dev_driver = {
	.driver = {
		.name = PLATFORM_DRIVER_NAME,
		.owner = THIS_MODULE,
		.of_match_table = syna_tcm2_of_match,
	},
	.probe = syna_dev_probe,
	.remove = syna_dev_remove,
};

static int __init syna_platform_init(void)
{
	return platform_driver_register(&syna_dev_driver);
}

late_initcall(syna_platform_init);

MODULE_AUTHOR("Synaptics, Inc.");
MODULE_DESCRIPTION("Synaptics TCM Touch Driver");
MODULE_LICENSE("GPL v2");

